/* jitter.c - experiments in jitter on Raspberry Pi boards
 *
 * This file contains all the target-independent stuff - tasks, ISRs etc.
 * The target-dependent stuff (startup, main, timer & uart functions) can be found in
 * hardware specific header/source files.
 *
 * (c) David Haworth
*/
#define DV_ASM	0
#include <dv-config.h>
#include <davroska.h>
#include <dv-stdio.h>
#include <dv-string.h>
#include <frame-manager.h>

/* This include file selects the hardware type
*/
#include TARGET_HDR

/* Task main functions, along with a description of how they interact.
 *
 * The hardware is assumed to have 4 LEDs that can be driven by output ports.
 *
 * The task Led is responsible for updating the set of LEDs. It is an extended task running at a fairly low
 * priority. It is the only task that actually modifies the state of the ports that drive the LEDs, so
 * no co-ordination is required for the hardware. However, it needs to get a consistent state of the
 * LED bits, so it uses a mutex that is shared with the three bit-flip tasks.
 *
 * The tasks Bit0, Bit1 and Bit2 are each responsible for "incrementing" a single bit of an LED state counter.
 * 		"Incrementing" means inverting the state:
 *			if the new state is 0 (carry) the next bit task is chained.
 *			if the new state is 1 an update event is sent to the Led task.
 *		Bit0 is activated by an alarm once per second.
 *		Bit2 has no carry, so it always sends the event.
 *
 * The final Led's state is controlled by a pseudo-random noise generator in the Bit3 task.
 * Bit3 is an extended task that expects to be sent the 
 * These messages are sent as a somewhat irregular rate that is generated by changing the return value
 * of the alarm trigger function that sends the event.
*/
/* Object identifiers
*/
dv_id_t T5a, T5b, T10a, T10b, T20a, T20b, T20c, T20d;	/* Tasks */
dv_id_t Timer;			/* ISRs */

/* main_T5a() - task body function for the 5ms 'a' task (start of every frame)
*/
void main_T5a(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T5b() - task body function for the 5ms 'b' task (end of every frame)
*/
void main_T5b(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T10a() - task body function for the 10ms 'a' task (even frames)
*/
void main_T10a(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T10b() - task body function for the 10ms 'b' task (odd frames)
*/
void main_T10b(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T20a() - task body function for the 10ms 'a' task (frame 0)
*/
void main_T20a(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T20b() - task body function for the 10ms 'b' task (frame 1)
*/
void main_T20b(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T20c() - task body function for the 10ms 'c' task (frame 2)
*/
void main_T20c(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_T20d() - task body function for the 10ms 'd' task (frame 3)
*/
void main_T20d(void)
{
	fm_TaskStart();
	fm_TaskEnd();
}

/* main_Timer() - body of ISR to handle interval timer interrupt
*/
void main_Timer(void)
{
	hw_ClearTimer();
}

/* callout_addtasks() - configure the tasks
*/
void callout_addtasks(dv_id_t mode)
{
	T5a = dv_addtask("T5a", &main_T5a, 4, 1);
	T5b = dv_addtask("T5b", &main_T5b, 4, 1);
	T10a = dv_addtask("T10a", &main_T10a, 4, 1);
	T10b = dv_addtask("T10b", &main_T10b, 4, 1);
	T20a = dv_addtask("T20a", &main_T20a, 4, 1);
	T20b = dv_addtask("T20b", &main_T20b, 4, 1);
	T20c = dv_addtask("T20c", &main_T20c, 4, 1);
	T20d = dv_addtask("T20d", &main_T20d, 4, 1);

	fm_CreateTasks();
}

/* callout_addisrs() - configure the isrs
*/
void callout_addisrs(dv_id_t mode)
{
	Timer = dv_addisr("Timer", &main_Timer, hw_TimerInterruptId, 8);
}

/* callout_addgroups() - configure the executable groups
*/
void callout_addgroups(dv_id_t mode)
{
}

/* callout_addmutexes() - configure the mutexes
*/
void callout_addmutexes(dv_id_t mode)
{
}

/* callout_addcounters() - configure the counters
*/
void callout_addcounters(dv_id_t mode)
{
}

/* callout_addalarms() - configure the alarms
*/
void callout_addalarms(dv_id_t mode)
{
}

/* callout_autostart() - start the objects that need to be running after dv_startos()
*/
void callout_autostart(dv_id_t mode)
{
	fm_Init();

	/* This sequuence defines the tasks in each frame as well as the order
	*/
	fm_AddTask(0, T5a);		/* Frame 0 */
	fm_AddTask(0, T10a);
	fm_AddTask(0, T20a);
	fm_AddTask(0, T5b);

	fm_AddTask(1, T5a);		/* Frame 1 */
	fm_AddTask(1, T10b);
	fm_AddTask(1, T20b);
	fm_AddTask(1, T5b);

	fm_AddTask(2, T5a);		/* Frame 2 */
	fm_AddTask(2, T10a);
	fm_AddTask(2, T20c);
	fm_AddTask(2, T5b);

	fm_AddTask(3, T5a);		/* Frame 3 */
	fm_AddTask(3, T10b);
	fm_AddTask(3, T20d);
	fm_AddTask(3, T5b);

	hw_InitialiseMillisecondTicker(5);
	dv_enable_irq(hw_TimerInterruptId);
}

/* callout_reporterror() - called if an error is detected
*/
dv_statustype_t callout_reporterror(dv_sid_t sid, dv_statustype_t e, dv_qty_t nparam, dv_param_t *param)
{
	dv_printf("callout_reporterror(%d, %d, %d, ...) called.\n", sid, e, nparam);
	for (int i = 0; i < nparam; i++ )
	{
		/* Only print the lower 32 bits of the parameters
		*/
		dv_printf("    param[%d] = %d (0x%08x)\n", i, (dv_u32_t)param[i], (dv_u32_t)param[i]);
	}

	for (;;) {} /* Temporary */
	return e;
}

/* callout_shutdown() - called on shutdown
*/
void callout_shutdown(dv_statustype_t e)
{
	dv_printf("callout_shutdown: %d\n", e);
}

/* callout_idle() - called in idle loop
*/
void callout_idle(void)
{
	dv_printf("Idle loop reached\n");
	for (;;) {}
}

/* callout_panic() - called from dv_panic
*/
void callout_panic(dv_panic_t p, dv_sid_t sid, char *fault)
{
	dv_printf("Panic %d in %d : %s\n", p, sid, fault);
}

/* main() - well, it's main, innit?
*/
int main(int argc, char **argv)
{
	dv_printf("davroska starting ...\n");

	dv_startos(0);

	return 0;
}
